"use strict";let PLAYER_1=0,PLAYER_2=1,NUM_PLAYERS=2;class RectGameBoard{constructor(e,r,t){this.c=e;this.r=r;this.cut=t;this.tiles=[];this.createBoard()}createBoard(){for(let e=0;e<this.r;e++){this.tiles[e]=[];for(let r=0;r<this.c;r++)this.tiles[e][r]=new BoardTile(e,r)}this.cut&&(this.tiles[0][0]=null,this.tiles[this.r-1][this.c-1]=null);let e=Math.floor(this.r/2)-1,r=Math.floor(this.c/2)-1;this.tiles[e][r].owner=PLAYER_1;this.tiles[e][r+1].owner=PLAYER_2;this.tiles[e+1][r].owner=PLAYER_2;this.tiles[e+1][r+1].owner=PLAYER_1;this.tiles[1][1].score=5;this.tiles[1][this.c-2].score=5;this.tiles[this.r-2][1].score=5;this.tiles[this.r-2][this.c-2].score=5}doMove(e,r,t){if(this.getValidMoves(t).includes(this.tiles[e][r])){this.claim(e,r,t);return!0}return!1}claim(e,r,t){let i=this.tiles[e][r];for(let e=0;e<6;e++){let r=[],n=i;do{let i=n.getDirection(e);if(this.tiles[i.r]!==void 0&&this.tiles[i.r][i.c]){if(this.tiles[i.r][i.c].owner===void 0){r=[];break}else if(this.tiles[i.r][i.c].owner===t){break}else n=this.tiles[i.r][i.c],r.push(n)}else{r=[];break}}while(!0);r.forEach(e=>e.setOwner(t))}i.setOwner(t)}score(e,r,t){let i=this.tiles[e][r],n=0;for(let e=0;e<6;e++){let r=[],o=i;do{let i=o.getDirection(e);if(this.tiles[i.r]!==void 0&&this.tiles[i.r][i.c]){if(this.tiles[i.r][i.c].owner===void 0){r=[];break}else if(this.tiles[i.r][i.c].owner===t){break}else o=this.tiles[i.r][i.c],r.push(o)}else{r=[];break}}while(!0);r.forEach(e=>n+=e.score)}n+=i.score;return n}getValidMoves(e){let r=[];for(let t=0;t<this.r;t++){for(let i=0;i<this.c;i++){let n=this.tiles[t][i];n!==null&&n.owner===(e+1)%NUM_PLAYERS&&(r=r.concat(n.getSiblings().filter(e=>this.tiles[e.r]!==void 0).map(e=>this.tiles[e.r][e.c]).filter(e=>e).filter(e=>e.owner===void 0)))}}return r}isBoardFilled(){for(let e=0;e<this.r;e++){for(let r=0;r<this.c;r++){if(this.tiles[e][r]!==null&&this.tiles[e][r].owner===void 0){return!1}}}return!0}getScores(){let e=[];for(let r=0;r<this.r;r++){for(let t=0;t<this.c;t++)this.tiles[r][t]!==null&&this.tiles[r][t].owner!==void 0&&(e[this.tiles[r][t].owner]===void 0?(e[this.tiles[r][t].owner]=this.tiles[r][t].score):(e[this.tiles[r][t].owner]+=this.tiles[r][t].score))}return e}getBoardTile(e,r){return this.tiles[e][r]}}class BoardTile{constructor(e,r){this.r=e;this.c=r;this.owner=void 0;this.score=1}setOwner(e){this.owner=e}getDirection(e){let r=this.r,t=this.c,i=!(this.r%2);switch(e){case 0:return{r:r+0,c:t+1};case 1:if(i)return{r:r+1,c:t+0};else return{r:r+1,c:t+1};case 2:if(i)return{r:r+1,c:t-1};else return{r:r+1,c:t+0};case 3:return{r:r+0,c:t-1};case 4:if(i)return{r:r-1,c:t-1};else return{r:r-1,c:t+0};case 5:if(i)return{r:r-1,c:t+0};else return{r:r-1,c:t+1};default:return void 0}}getSiblings(){let e=[];for(let r=0;r<6;r++)e.push(this.getDirection(r));return e}}