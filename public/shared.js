"use strict";let PLAYER_1=0,PLAYER_2=1,NUM_PLAYERS=2;class RectGameBoard{constructor(e,r,t){this.c=e;this.r=r;this.cut=t;this.tiles=[];this.createBoard()}createBoard(){for(let e=0;e<this.r;e++){this.tiles[e]=[];for(let r=0;r<this.c;r++)this.tiles[e][r]=new BoardTile(e,r)}this.cut&&(this.tiles[0][0]=null,this.tiles[this.r-1][this.c-1]=null);let e=Math.floor(this.r/2)-1,r=Math.floor(this.c/2)-1;this.tiles[e][r].owner=PLAYER_1;this.tiles[e][r+1].owner=PLAYER_2;this.tiles[e+1][r].owner=PLAYER_2;this.tiles[e+1][r+1].owner=PLAYER_1;this.tiles[1][this.c-2].score=5;this.tiles[this.r-2][1].score=5;this.tiles[0][0].bonus=!0;this.tiles[this.r-1][this.c-1].bonus=!0}doMove(e,r,t){if(this.getValidMoves(t).includes(this.tiles[e][r])){this.claim(e,r,t);return!0}return!1}claim(e,r,t){let n=this.tiles[e][r],o=n.bonus;for(let e=0;e<6;e++){let r=[],i=n;do{let n=i.getDirection(e);if(this.tiles[n.r]!==void 0&&this.tiles[n.r][n.c]){if(this.tiles[n.r][n.c].owner===void 0){r=[];break}else if(this.tiles[n.r][n.c].owner===t){break}else i=this.tiles[n.r][n.c],r.push(i)}else{r=[];break}}while(!0);r.forEach(e=>{e.setOwner(t),o&&(e.score+=1)})}n.setOwner(t);o&&(n.score+=1)}score(e,r,t){let n=this.tiles[e][r],o=n.bonus,i=0;for(let e=0;e<6;e++){let r=[],s=n;do{let n=s.getDirection(e);if(this.tiles[n.r]!==void 0&&this.tiles[n.r][n.c]){if(this.tiles[n.r][n.c].owner===void 0){r=[];break}else if(this.tiles[n.r][n.c].owner===t){break}else s=this.tiles[n.r][n.c],r.push(s)}else{r=[];break}}while(!0);r.forEach(e=>i+=e.score+(o?1:0))}i+=n.score+(o?1:0);return i}getValidMoves(e){let r=[];for(let t=0;t<this.r;t++){for(let n=0;n<this.c;n++){let o=this.tiles[t][n];o!==null&&o.owner===(e+1)%NUM_PLAYERS&&(r=r.concat(o.getSiblings().filter(e=>this.tiles[e.r]!==void 0).map(e=>this.tiles[e.r][e.c]).filter(e=>e).filter(e=>e.owner===void 0)))}}return r}isBoardFilled(){for(let e=0;e<this.r;e++){for(let r=0;r<this.c;r++){if(this.tiles[e][r]!==null&&this.tiles[e][r].owner===void 0){return!1}}}return!0}getScores(){let e=[];for(let r=0;r<this.r;r++){for(let t=0;t<this.c;t++)this.tiles[r][t]!==null&&this.tiles[r][t].owner!==void 0&&(e[this.tiles[r][t].owner]===void 0?(e[this.tiles[r][t].owner]=this.tiles[r][t].score):(e[this.tiles[r][t].owner]+=this.tiles[r][t].score))}return e}getBoardTile(e,r){return this.tiles[e][r]}}class BoardTile{constructor(e,r){this.r=e;this.c=r;this.owner=void 0;this.bonus=!1;this.score=1}setOwner(e){this.owner=e}getDirection(e){let r=this.r,t=this.c,n=!(this.r%2);switch(e){case 0:return{r:r+0,c:t+1};case 1:if(n)return{r:r+1,c:t+0};else return{r:r+1,c:t+1};case 2:if(n)return{r:r+1,c:t-1};else return{r:r+1,c:t+0};case 3:return{r:r+0,c:t-1};case 4:if(n)return{r:r-1,c:t-1};else return{r:r-1,c:t+0};case 5:if(n)return{r:r-1,c:t+0};else return{r:r-1,c:t+1};default:return void 0}}getSiblings(){let e=[];for(let r=0;r<6;r++)e.push(this.getDirection(r));return e}}